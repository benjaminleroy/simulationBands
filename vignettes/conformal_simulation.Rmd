---
title: "simulation_flexcode"
output: html_document
---

```{r echo = F, message = F, warning = F}
library(tidyverse)
library(FlexCoDE)
library(tikzDevice)
library(pracma)
theme_set(theme_minimal())
```

**General idea**

1. Create a simulation
2. make a slighty shitty model
3. demostrate the approach

```{r echo = F}
gen_mix_reg <- function(x, beta = c(-1,1), 
                        intercept = c(0,0),  
                        sd = c(1,1), 
                        proportions = c(.5,.5)) {
  assertthat::assert_that(all(length(beta) == length(intercept),
                              length(beta) == length(sd),
                              length(beta) == length(proportions)),
                          msg = "parameters should be of the correct length")
  
  n <- length(beta)
  
  group_id <- sample(1:n, size = length(x), prob = proportions, replace = T)
  
  beta_x <- beta[group_id]
  intercept_x <- intercept[group_id]
  sd_x <- sd[group_id]
  
  return(intercept_x + beta_x * x + rnorm(n = length(x), sd = sd_x))
}

X <- runif(n = 1000, min = -1, 10)
y <- gen_mix_reg(X)

data <- data.frame(x = X, y = y)

data2 <- data.frame(x = runif(n = 500, min = -6,-1),
                    y = rnorm(n = 500))
data_all <- rbind(data, data2)
``` 


```{r echo = F}
data_vis <- data_all %>%
  ggplot() +
  geom_point(aes(x = x, y = y))


data_vis 

if (FALSE){
  tikz(file = paste0("~/Documents/CMU/research_write_up/chad_documents/",
                     "report21oct2020/images/raw_data.tex"), 
       width = 5, height = 5)
  print(data_vis)
  dev.off()
}

```

```{r echo = F}
library(flexmix)

model <- flexmix(y~x, k = 2, data = data_all)
summary(model)

```
```{r echo = F}
beta <- sapply(model@components, function(item) item[[1]]@parameters$coef[2])
intercept <- sapply(model@components, function(item) item[[1]]@parameters$coef[1])
sigma <- sapply(model@components, function(item) item[[1]]@parameters$sigma)
proportion <- model@prior
```

```{r echo = F}
y_all <- gen_mix_reg(x = data_all$x, beta = beta, 
                     intercept = intercept,
                     sd = sigma,
                     proportions = proportion)
model_sim_vis <- data.frame(x = data_all$x, y = y_all) %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(color = "red") #+
  #geom_point(data = data_all, color = "black")

model_sim_vis

if (FALSE){
  tikz(file = paste0("~/Documents/CMU/research_write_up/chad_documents/",
                     "report21oct2020/images/sim_data.tex"),
       width = 5, height = 5)
  print(model_sim_vis)
  dev.off()
}
```

```{r echo = F}
library(gridExtra)
vis_list <- list()
y_sim_list <- list()
for (x_val in c(2.5,5,10)){
  y_sim <- gen_mix_reg(x = rep(x_val, 100), beta = beta, 
                     intercept = intercept,
                     sd = sigma,
                     proportions = proportion)
  y_sim_list[[as.character(x_val)]] <- y_sim
  vis_list[[as.character(x_val)]] <- data_all %>%
  ggplot() +
  geom_point(aes(x = x, y = y), alpha = .1) +
  geom_point(data = data.frame(x = rep(x_val,100), y = y_sim),
             aes(x=x, y = y), color = "red", alpha = .1)
}

grid.arrange(grobs = vis_list, nrow = 2)
```

```{r}
multimode_density_f <- function(y, x_val, beta = c(-1,1), 
                        intercept = c(0,0),  
                        sd = c(1,1), 
                        proportions = c(.5,.5)){
  means <- beta * x_val + intercept
  
  prob <- t(dnorm(t(matrix(rep(y, each = 2), ncol = 2, byrow = T)),
                        sd = sd, mean =  means)) %*% 
     matrix(proportions, nrow = 2)
  return(prob)
}
delta <- .1
vis1d_list <- list()

xx_values <- seq(-15,15, by = .1)
for (x_val in c(2.5,5,10)){
  true_density <- multimode_density_f(xx_values, x_val)
  model_density <- multimode_density_f(xx_values, x_val, 
                                         beta = beta, 
                                         intercept = intercept,
                                         sd = sigma,
                                         proportions = proportion)
  vis_data <- data.frame(y = c(true_density, model_density),
                         x = c(xx_values, xx_values),
                         group = c(rep("true distribution", length(xx_values)),
                                   rep("model distribution", length(xx_values))))
  vis1d_list[[as.character(x_val)]] <- ggplot(vis_data) +
    geom_path(aes(x= y, y = x, color = group)) +
    scale_color_manual(values = c("red", "black")) +
    scale_y_continuous(limits = c(-15,15),
                       sec.axis = sec_axis(~.,name = paste0("x value: ", 
                                                            x_val)))
}
```


```{r}
make_legend_color  <- function(unique_names, colors = scales::hue_pal()(length(unique_names))){
  n <- length(unique_names)
  ncol <- n %||% ceiling(sqrt(length(unique_names)))
  nrow <- ceiling(n/ncol)
  unique_names <- c(unique_names, rep(NA, nrow * ncol - length(colors)))
  colors <- c(colors, rep(NA, nrow * ncol - length(colors)))
  colors <- matrix(colors, ncol = ncol, byrow = TRUE) %>%
    as.data.frame %>% add_rownames() %>%
    tidyr::pivot_longer(cols = - rowname, names_to = "columns",
                        values_to = "color")
  unique_names <- matrix(unique_names, ncol = ncol, 
                         byrow = TRUE) %>%
    as.data.frame %>% add_rownames() %>%
    tidyr::pivot_longer(cols = - rowname, names_to = "columns",
                        values_to = "name")
  
  vis_df <- colors %>% 
    left_join(unique_names, by = c("rowname", "columns")) %>%
    mutate(columns = stringr::str_replace(columns,"V", "")) %>%
    mutate(rowname = as.numeric(rowname),
           columns = as.numeric(columns))
    
  color_vector <- vis_df$color
  names(color_vector) <- vis_df$name
  
  legend_vis <- vis_df %>% ggplot() +
    geom_tile(aes(x = rowname, y = columns, fill = name)) +
    geom_label(aes(x = rowname, y = columns, label = name)) +
    scale_fill_manual(values = color_vector) +
    theme_void() +
    theme(legend.position = "none", aspect.ratio = 1)  +
    labs(x = "", y = "") 
    
  
  return(legend_vis)
  
}
```


```{r}
legend_vis <- make_legend_color(c("true distribution", "model distribution"), 
                                colors = c("black", "red"))
vis1d_list <- lapply(vis1d_list, function(gg) gg+theme(legend.position = "none"))
vis1d_list[["mylegend"]] <- legend_vis

grid.arrange(grobs = vis1d_list,
             nrow = 2)
```

```{r}
vis_all_list <- list(vis_list[[1]] + ylim(-15, 15), vis1d_list[[1]],
                     vis_list[[2]] + ylim(-15, 15), vis1d_list[[2]],
                     vis_list[[3]] + ylim(-15, 15), vis1d_list[[3]])

grid.arrange(grobs = vis_all_list,
             nrow = 3)

compare_vis <- arrangeGrob(grobs  = vis_all_list,
             nrow = 3)


if (FALSE){
  ggsave(file = paste0("~/Documents/CMU/research_write_up/chad_documents/",
                     "report21oct2020/images/compare.pdf"), compare_vis,
         width = 5, height = 7)
}
```



```{r}
# conformal scores
# X1 <- runif(n = 100, min = -1, 10)
# conformal_data <- data.frame(x = c(X1,
#                    runif(n = 50, min = -6, max = -1)),
#              y = c(gen_mix_reg(X1),
#                    rnorm(n = 50)))

conformal_data <- data.frame(x = runif(n = 1000, 9, 10)) %>%
  mutate(y = gen_mix_reg(x))
```

```{r}
# get conformal scores from simulations

conformal_score_f <- function(x,y, model_params, sim_num = 100){
  y_values <- gen_mix_reg(x = rep(x, sim_num), beta = model_params$beta, 
                     intercept = model_params$intercept,
                     sd = model_params$sd,
                     proportions = model_params$prop)
  
  density_estimate <- ks::kde(y_values, h = .1)
  prob <- predict(density_estimate, x = y_values)
  prob_x <- predict(density_estimate, x = y)
  
  return(mean(prob <= prob_x))
}

conformal_score_p <- function(x,y, model_params, sim_num = 100){
  y_values <- gen_mix_reg(x = rep(x, sim_num), beta = model_params$beta, 
                     intercept = model_params$intercept,
                     sd = model_params$sd,
                     proportions = model_params$prop)
  
  density_estimate <- ks::kde(y_values, h = .1)
  prob_x <- predict(density_estimate, x = y)
  
  return(prob_x)
}

sim_conformal_scores <- function(x,y, model_params, sim_num = 100, h = .4,
                                 grid = seq(-15, 15, by = .01)){
    y_values <- gen_mix_reg(x = rep(x, sim_num), beta = model_params$beta, 
                     intercept = model_params$intercept,
                     sd = model_params$sd,
                     proportions = model_params$prop)
    
  density_estimate <- ks::kde(y_values, h = h)
  prob <- predict(density_estimate, x = y_values)
  prob_x <- predict(density_estimate, x = y)
  prob_xx <- predict(density_estimate, x = grid)
  
  df_out <- data.frame(cde_compared_to_sim = mean(prob <= prob_x),
                       ecde = prob_x,
                       proportion_above_threshold = sum(prob_xx[prob_xx >= prob_x])*.01)
  return(df_out)
}




model_params <- list(beta = beta, intercept = intercept,
                     sd = sigma, prop = proportion)

# sim_cs <- data.frame(matrix(nrow = 0, ncol = 2))
# names(sim_cs) <- c("cde_compared_to_sim", "ecde")
# 
# density_cs <- rep(NA, nrow(conformal_data))
# 
# for (i in 1:nrow(conformal_data)){
#   x <- conformal_data$x[i]
#   y <- conformal_data$y[i]
#   sim_cs <- rbind(sim_cs, 
#                   sim_conformal_scores(x, y,
#                                        model_params, sim_num = 100))
#   density_cs[i] <- multimode_density_f(y, x, 
#                                        beta = beta, 
#                                        intercept = intercept,
#                                        sd = sigma,
#                                        proportions = proportion)
# }
# 
# info <- conformal_data %>% cbind(sim_cs) %>%
#   mutate(density_cs = density_cs)
info <- conformal_data %>% 
  mutate(id = 1:nrow(conformal_data)) %>%
  group_by(id) %>%
  nest() %>%
  mutate(sim_cs = purrr::map(data, function(df) sim_conformal_scores(df$x, df$y,
                                                                     model_params, sim = 100)),
         density_cs = purrr::map(data, function(df) multimode_density_f(df$y, df$x, 
                                       beta = beta,
                                       intercept = intercept,
                                       sd = sigma,
                                       proportions = proportion))) %>%
  unnest(col = c(sim_cs, density_cs))

info %>% 
  ggplot() +
  geom_point(aes(x = ecde, y= proportion_above_threshold))
```



```{r}
library(ggfortify)
p1 <- autoplot(ecdf(info$ecde)) +
  labs(title = "CDE estimate",
       y = "proportion")
p2 <- autoplot(ecdf(info$cde_compared_to_sim)) +
  labs(title = "proportion of samples with lower CDE",
       y = "proportion")

p3 <- autoplot(ecdf(info$density_cs)) +
  labs(title = "True CDE from model",
       y = "proportion")

p4 <- autoplot(ecdf(info$proportion_above_threshold)) +
  labs(title = "mass with cde estimate above value",
       y = "proportion")


grid.arrange(p1, p2, p3, p4, nrow = 2, top = "Empirical CDFs of conformal scores based on ")
ecdf_conformal <- arrangeGrob(grobs = list(p1, p2, p3, p4), nrow = 2, 
            top = "Empirical CDFs of conformal scores based on ")


if (FALSE){
  ggsave(file = paste0("~/Documents/CMU/research_write_up/chad_documents/",
                     "report21oct2020/images/ecdf_conformal.pdf"), 
         ecdf_conformal,
         width = 10, height = 10)
}
```


```{r}
# creating level sets / updating the probabibilty values
# only CDE approach.

# need to estimate probability mass 

# first data frame:
x <- 9.5
delta_y <- .01
yy <- seq(-15, 15, by = delta_y)
first_df <- data.frame(yy = yy,
           density = multimode_density_f(yy, x, 
                                         beta = beta, 
                                         intercept = intercept,
                                         sd = sigma,
                                         proportions = proportion)) %>%
  mutate(g_id = cut(density, breaks = c(-Inf, sort(info$ecde), Inf)),
         g_id2 = cut(density, breaks = c(-Inf, sort(info$ecde), Inf), labels = F))

# xx | density | g_id = cut(density, breaks = lambdas) 

# second data frame:
second_df <- first_df %>%
  group_by(g_id, g_id2) %>%
  summarize(prop = sum(density)*delta_y) %>%
  ungroup() %>%
  mutate(cum_prop = cumsum(prop),
         prop_lag = dplyr::lag(prop, default = 0),
         cum_prop_lag = cumsum(prop_lag)) %>%
  mutate(cut_off_lower = str_extract(as.character(g_id), "(\\((-*[0-9]+\\.*[0-9]*)\\,)|(\\(-Inf\\,)"), 
         cut_off_lower = str_extract(cut_off_lower, "(-*[0-9]+\\.*[0-9]*)|(-Inf)"),
         cut_off_lower = as.numeric(cut_off_lower)) %>%
  mutate(cut_off_upper = str_extract(as.character(g_id), "(\\,-*[0-9]+\\.*[0-9]*\\])|(\\,Inf])"),
         cut_off_upper = str_extract(cut_off_upper, "(-*[0-9]+\\.*[0-9]*)|(Inf)"),
         cut_off_upper = as.numeric(cut_off_upper)) %>%
  mutate(prob_above_lower = 1-cum_prop_lag)

n <- max(length(info$ecde), length(levels(first_df$g_id)))

all_df <- first_df %>% left_join(second_df, by = c("g_id", "g_id2")) %>%
  mutate(cum_prop2 = cum_prop - prop) %>%
  mutate(density2 = density * 1/(prop*n)) %>%
  mutate(density3 = density)

# for (id in 1:(length(levels(first_df$g_id)) - 1)) {
#   g_id <- levels(first_df$g_id)[id]
#   all_df$density3[all_df$g_id == g_id] <- all_df$density[all_df$g_id == g_id] * (1-id/n) * 1/(1-second_df$cum_prop[second_df$g_id == g_id]+ second_df$prop[second_df$g_id == g_id])
# }

all_df <- all_df %>% 
  mutate(density3 = density * (n-g_id2)/n *1/prob_above_lower)


all_df %>% ggplot() +
  geom_line(aes(x = yy, y = density)) +
  geom_line(aes(x = yy, y = density2), color = "blue") +
  geom_line(aes(x = yy, y = density3), color = "red")


data.frame(num_breaks = first_df$g_id %>% levels %>% unique %>% length,
           num_unique_breaks = first_df$g_id2  %>% unique %>% length,
           max_m_plus_1 = first_df$g_id2  %>% max)
```


```{r}
second_df %>%
  ggplot() +
  geom_point(aes(x = (1-g_id2/n), y = (prob_above_lower), color = g_id2)) +
  geom_line(aes(x = (1-g_id2/n), y = (prob_above_lower))) +
  geom_abline(slope = 1, intercept = 0)

second_df %>%
  ggplot() +
  geom_point(aes(x = g_id2, y = (1-g_id2/n)/(prob_above_lower))) +
  geom_line(aes(x = g_id2, y = (1-g_id2/n)/(prob_above_lower))) +
  geom_smooth(aes(x = g_id2, y = (1-g_id2/n)/(prob_above_lower)),
              method = "lm")

lm((1-g_id2/n)/(prob_above_lower) ~ g_id2, data = second_df)

all_df %>% 
  ggplot(aes(x = density, y = density3)) +
  geom_point() +
  geom_line()
```


# linear program

```{r}
library(lpSolve)



n <- 5
prob_cde <- rep(1/6,6)

create_equality_matrix <- function(n, prob_cde){
  # Equalities
  # 1. conformal constraints
  
  m1.1 <- matrix(0, nrow = n + 1, ncol = n + 1)
  m1.1[lower.tri(m1.1, diag = T)] <- 1
  m1.1 <- m1.1[, ncol(m1.1):1]
  
  m1.2 <- diag(prob_cde)
  
  m1.3 <- m1.1 %*% m1.2
  slack_mat1 <- matrix(0, nrow = n+1, ncol = n)
  
  lhs1 <- cbind(m1.3, slack_mat1)
  
  rhs1 <- 1 - (n:0)/(n+1)
  
  return(list(lhs1, rhs1))
}


create_inequality_matrices <- function(n) {
  # Inequalities 
  # 2. a_i \geq 0 => - a_i \leq 0
  m2 <- -1 * diag(n+1)
  
  slack_mat2 <- matrix(0, nrow = n+1, ncol = n)
  
  lhs2 <- cbind(m2, slack_mat2)
  rhs2 <- rep(0, n+1)
  
  # 3. monotonic with slack?
  m3.1 <- diag(1, nrow = n+1, ncol = n+1)
  m3.2 <- Diag(rep(-1, n),k = +1) 
  m3.3 <- m3.1 + m3.2
  m3.4 <- m3.3[-nrow(m3.3),]
  
  slack_mat3.1 <- diag(x = -1, nrow = n, ncol = n)
  
  lhs3 <- cbind(m3.4, slack_mat3.1)
  rhs3 <- rep(0, n)
  
  # 4 slack_i \geq 0
  slack_mat4 <- diag(1, nrow = n, ncol = n)
  
  m4 <- matrix(0, ncol = n+1, nrow = n)
  
  lhs4 <- cbind(m4, slack_mat4)
  rhs4 <- rep(0, n)
  
  # INEQUALITIES ALL
  lhs_all_ineq <- rbind(lhs2, lhs3, lhs4)
  rhs_all_ineq <- c(rhs2, rhs3, rhs4)
  
  return(list(lhs_all_ineq, rhs_all_ineq))
}

create_inequality_matrices2 <- function(n) {
  # Inequalities 
  # 2. a_i \geq 0 => - a_i \leq 0
  m2 <- -1 * diag(n+1)
  
  slack_mat2 <- matrix(0, nrow = n+1, ncol = n)
  
  lhs2 <- cbind(m2, slack_mat2)
  rhs2 <- rep(0, n+1)
  
  # 3. monotonic with slack?
  m3.1 <- diag(1, nrow = n+1, ncol = n+1)
  m3.2 <- Diag(rep(-1, n),k = +1) 
  m3.3 <- m3.1 + m3.2
  m3.4 <- m3.3[-nrow(m3.3),]
  
  slack_mat3.1 <- diag(x = -1, nrow = n, ncol = n)
  
  lhs3 <- cbind(m3.4, slack_mat3.1)
  rhs3 <- rep(0, n)
  
  # # 4 slack_i \geq 0
  # slack_mat4 <- diag(1, nrow = n, ncol = n)
  # 
  # m4 <- matrix(0, ncol = n+1, nrow = n)
  # 
  # lhs4 <- cbind(m4, slack_mat4)
  # rhs4 <- rep(0, n)
  
  # INEQUALITIES ALL
  lhs_all_ineq <- rbind(lhs2, lhs3)#, lhs4)
  rhs_all_ineq <- c(rhs2, rhs3)#, rhs4)
  
  return(list(lhs_all_ineq, rhs_all_ineq))
}


# all constaints
const.mat <- rbind(lhs1, lhs_all_ineq)
const.dir <- c(rep("==", nrow(lhs1)), rep("<=", nrow(lhs_all_ineq)))
const.rhs <- c(rhs1, rhs_all_ineq)

# cost function
c <- c(rep(0, n+1), rep(1, n))

lp_out <- lp(direction = "min",
   objective.in = c,
   const.mat = const.mat,
   const.dir = const.dir,
   const.rhs = const.rhs)

```


```{r}
# test data (already conformal):
n <- 5
prob_cde <- rep(1/6,6)
potential_solution <- c(rep(1,n+1), rep(0,n))

eq_mats <- create_equality_matrix(n, prob_cde)
lhs_eq <- eq_mats[[1]]
rhs_eq <- eq_mats[[2]]

testthat::expect_equal(lhs_eq %*% potential_solution, 
                       matrix(rhs_eq, ncol = 1))

ineq_mats <- create_inequality_matrices(n)
lhs_ineq <- ineq_mats[[1]]
rhs_ineq <- ineq_mats[[2]]

testthat::expect_true(all(lhs_ineq %*% potential_solution <= matrix(rhs_ineq, ncol = 1)))


# all constaints
const.mat <- rbind(lhs_eq, lhs_ineq)
const.dir <- c(rep("==", nrow(lhs_eq)), rep("<=", nrow(lhs_ineq)))
const.rhs <- c(rhs_eq, rhs_ineq)

# cost function
c <- c(rep(0, n+1), rep(1, n))

lp_out <- lp(direction = "min",
   objective.in = c,
   const.mat = const.mat,
   const.dir = const.dir,
   const.rhs = const.rhs)

solution <- lp_out$solution[1:n+1]

testthat::expect_equal(lp_out$solution, potential_solution)


```





```{r}
global_optimization_lp <- function(n, prob_cde){
  # equality constraints
  eq_mats <- create_equality_matrix(n, prob_cde)
  lhs_eq <- eq_mats[[1]]
  rhs_eq <- eq_mats[[2]]
  
  # inequality constraints
  ineq_mats <- create_inequality_matrices(n)
  lhs_ineq <- ineq_mats[[1]]
  rhs_ineq <- ineq_mats[[2]]
  
  # all constaints
  const.mat <- rbind(lhs_eq, lhs_ineq)
  const.dir <- c(rep("==", nrow(lhs_eq)), rep("<=", nrow(lhs_ineq)))
  const.rhs <- c(rhs_eq, rhs_ineq)
  
  # cost function
  c <- c(rep(0, n+1), rep(1, n))
  
  lp_out <- lp(direction = "min",
     objective.in = c,
     const.mat = const.mat,
     const.dir = const.dir,
     const.rhs = const.rhs)

  return(list(lp_out, lp_out$solution[1:(n+1)]))  

}
```


```{r}
library(quadprog)
global_optimization_qp <- function(n, prob_cde){
  # equality constraints
  eq_mats <- create_equality_matrix(n, prob_cde)
  lhs_eq <- eq_mats[[1]]
  rhs_eq <- eq_mats[[2]]
  
  # inequality constraints
  ineq_mats <- create_inequality_matrices2(n)
  lhs_ineq <- -1 * ineq_mats[[1]]
  rhs_ineq <- -1 * ineq_mats[[2]]
  
  
  
  # all constaints
  const.mat <- rbind(lhs_eq, lhs_ineq)
  const.rhs <- c(rhs_eq, rhs_ineq)
  
  # cost function
  c <- c(rep(0, n+1), rep(1, n))
  Dmat <- diag(c) 

  browser()
  
  qp_out <- solve.QP(Dmat, dvec = rep(0, 2*n+1), Amat = t(const.mat),
                     bvec = const.rhs,
                     meq = nrow(lhs_eq), factorized = T)

  return(list(qp_out))  

}
```


```{r}
n <- 5
prob_cde <- rep(1/6,6)
eq_mat <- create_equality_matrix(n, prob_cde)
lhs_eq = eq_mat[[1]]
rhs_eq = eq_mat[[2]]

n_plus_1 <- nrow(lhs_eq)
lhs_eq[,1:n_plus_1]

solve(lhs_eq[,1:n_plus_1]) %*% rhs_eq[1:n_plus_1]
```



```{r}
prop_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1

global_optimization_lp(n, prop_cde)
global_optimization_qp(n, prop_cde)

n <- 5
prob_cde <- rep(1/6,6)
global_optimization_qp(n, prob_cde)
```


```{r}
prop_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
eq_mat <- create_equality_matrix(n, prop_cde)
lhs_eq = eq_mat[[1]]
rhs_eq = eq_mat[[2]]

n_plus_1 <- nrow(lhs_eq)
lhs_eq[,1:n_plus_1]

transform <- solve(lhs_eq[,1:n_plus_1]) %*% rhs_eq[1:n_plus_1]

data.frame(multiplier = transform, x = 1:length(transform)) %>%
  ggplot() +
  geom_point(aes(x = x, y = log(multiplier))) +
  geom_line(aes(x = x, y = log(multiplier)))
```

```{r}
x <- 9.5
delta_y <- .001
yy <- seq(-15, 15, by = delta_y)
first_df <- data.frame(yy = yy,
           density = multimode_density_f(yy, x, 
                                         beta = beta, 
                                         intercept = intercept,
                                         sd = sigma,
                                         proportions = proportion)) %>%
  mutate(g_id = cut(density, breaks = c(-Inf, sort(info$ecde), Inf)),
         g_id2 = cut(density, breaks = c(-Inf, sort(info$ecde), Inf), labels = F))

second_df <- first_df %>%
  group_by(g_id, g_id2) %>%
  summarize(prop = sum(density)*delta_y) %>%
  ungroup() %>%
  mutate(cum_prop = cumsum(prop),
         prop_lag = dplyr::lag(prop, default = 0),
         cum_prop_lag = cumsum(prop_lag)) %>%
  mutate(cut_off_lower = str_extract(as.character(g_id), "(\\((-*[0-9]+\\.*[0-9]*)\\,)|(\\(-Inf\\,)"), 
         cut_off_lower = str_extract(cut_off_lower, "(-*[0-9]+\\.*[0-9]*)|(-Inf)"),
         cut_off_lower = as.numeric(cut_off_lower)) %>%
  mutate(cut_off_upper = str_extract(as.character(g_id), "(\\,-*[0-9]+\\.*[0-9]*\\])|(\\,Inf])"),
         cut_off_upper = str_extract(cut_off_upper, "(-*[0-9]+\\.*[0-9]*)|(Inf)"),
         cut_off_upper = as.numeric(cut_off_upper)) %>%
  mutate(prob_above_lower = 1-cum_prop_lag)

n <- max(length(info$ecde), length(levels(first_df$g_id)))


prop_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
eq_mat <- create_equality_matrix(n, prop_cde)
lhs_eq = eq_mat[[1]]
rhs_eq = eq_mat[[2]]

n_plus_1 <- nrow(lhs_eq)
# lhs_eq[,1:n_plus_1]

transform <- solve(lhs_eq[,1:n_plus_1]) %*% rhs_eq[1:n_plus_1]

data.frame(multiplier = transform, x = 1:length(transform)) %>%
  ggplot() +
  geom_point(aes(x = x, y = log(multiplier)))
```

```{r}
second_df$multiplier <- c(1, transform)

all_df2 <- first_df %>% left_join(second_df, by = c("g_id", "g_id2")) %>%
  mutate(cum_prop2 = cum_prop - prop) %>%
  mutate(density2 = density * 1/(prop*n)) %>%
  mutate(density3 = density * multiplier)


all_df2 %>% ggplot() +
  geom_line(aes(x = yy, y = density)) +
  #geom_line(aes(x = yy, y = density2), color = "blue") +
  geom_point(aes(x = yy, y = density3), color = "red") +
  geom_smooth(aes(x = yy, y = density3))


all_df2 %>%
  ggplot(aes(x = density, y = density3)) +
  geom_point()
```

# A smoothed attempt

\[
\min_{\alpha, z} 1/2 \alpha^T S^TS\alpha - b^TS\alpha + \lambda 1^Tz
\]
s.t.
\begin{eqnarray}
  z_i & \geq \alpha_i - \alpha_{i+1} \\
  z_i & \geq -(\alpha_i - \alpha_{i+1}) \\
  \alpha_i & \geq 0
\end{eqnarray}

```{r}

create_S_b_matrix <- function(n, prob_cde){
  # Equalities
  # 1. conformal constraints
  
  m1.1 <- matrix(0, nrow = n + 1, ncol = n + 1)
  m1.1[lower.tri(m1.1, diag = T)] <- 1
  m1.1 <- m1.1[, ncol(m1.1):1]
  
  m1.2 <- diag(prob_cde)
  
  m1.3 <- m1.1 %*% m1.2

  lhs1 <- m1.3
  
  rhs1 <- 1 - (n:0)/(n+1)
  
  return(list(lhs1, rhs1))
}

```


```{r}
prop_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1

eq_mat <- create_S_b_matrix(n, prop_cde)
lhs_eq <- eq_mat[[1]]
rhs_eq <- eq_mat[[2]]

lambda <- 1e-3 

# Dmat 
D_mat.1 <- 1/2 * t(lhs_eq) %*% lhs_eq
D_mat <- rbind(cbind(D_mat.1, matrix(0, nrow = nrow(D_mat.1),
                                     ncol = nrow(D_mat.1) - 1)),
               cbind(matrix(0, nrow = nrow(D_mat.1) - 1, 
                               ncol = nrow(D_mat.1)),
                     diag(rep(1e-12, nrow(D_mat.1) - 1))))

dvec <- c(t(rhs_eq) %*% lhs_eq, rep(-lambda, nrow(D_mat.1) - 1))

Amat1.1 <- diag(1, nrow = nrow(D_mat.1), ncol = nrow(D_mat.1))
Amat1.2 <- Diag(rep(-1, nrow(D_mat.1)-1),k = +1) 
Amat1.3 <- Amat1.1 + Amat1.2
Amat1.4 <- Amat1.3[-nrow(Amat1.3),]
Amat1 <- cbind(Amat1.4, diag(rep(1, nrow(D_mat.1) - 1)))

Amat2 <- cbind(-Amat1.4, diag(rep(1, nrow(D_mat.1) - 1)))

Amat3 <- cbind(diag(rep(1, nrow(D_mat.1))), matrix(0, nrow = nrow(D_mat.1),
                                                  ncol = nrow(D_mat.1) - 1))

Amat <- rbind(Amat1, Amat2, Amat3)
b_0_vec <- rep(0, nrow(Amat))

library(quadprog)
qp_solve <- solve.QP(Dmat = D_mat, dvec = dvec, 
                     Amat = t(Amat), bvec = b_0_vec, factorize = F)

transform_smooth <- qp_solve$solution
```

```{r}
data.frame(multiplier = transform_smooth, x = 1:length(transform_smooth)) %>%
  ggplot() +
  geom_point(aes(x = x, y = multiplier)) +
  geom_line(aes(x = x, y = multiplier))
```


```{r}
create_S_b_matrix <- function(n, prob_cde){
  # Equalities
  # 1. conformal constraints
  
  m1.1 <- matrix(0, nrow = n + 1, ncol = n + 1)
  m1.1[lower.tri(m1.1, diag = T)] <- 1
  m1.1 <- m1.1[, ncol(m1.1):1]
  
  m1.2 <- diag(prob_cde)
  
  m1.3 <- m1.1 %*% m1.2

  lhs1 <- m1.3
  
  rhs1 <- 1 - (n:0)/(n+1)
  
  return(list(lhs1, rhs1))
}


#' stepwise transform of CDE to become comformal
#'
#' Solving for the x in the following general equation
#' \deqn{\min_{x, z} 1/2(Sx-b)^T(Sx-b) + 
#'       \lambda (\alpha z^Tz + (1-\alpha) 1^Tz)}
#' subject to some of the following equations
#' \tabular{rl}{
#' \eqn{A_1}: & \eqn{z_i \geq x_i - x_{i+1}}  \\
#' \eqn{A_2}: & \eqn{z_i \geq - x_i + x_{i+1}}  \\
#' \eqn{A_3}: & \eqn{x_i \geq 0}  \\
#' \eqn{A_4}: & \eqn{x_i - x_{i+1} \geq 0}  \\
#' }
#'
#' With \eqn{A_1, A_2, A_3} constraints for \code{monotonically_increasing} is
#' \code{FALSE} and \eqn{A_1, A_3, A_4} if \code{monotonically_increasing} is
#' \code{TRUE}.
#'
#' @param n 
#' @param prob_cde 
#' @param lambda 
#' @param alpha 
#' @param monotonically_increasing 
#' @param delta 
#'
#' @return
#' @export
#'
#' @examples
stepwise_conformal_cde_update <- function(n, prob_cde,
                                          lambda = -1,
                                          alpha = 0,
                                          monotonically_increasing = F,
                                          delta = 1e-12,
                                          scaling_constraint = F){
  
  assertthat::assert_that(length(prob_cde) == n + 1,
                        msg = "size correct")
  assertthat::assert_that(lambda == -1 | lambda > 0,
                          msg = "lambda correct")
  if (lambda != -1){
    assertthat::assert_that(alpha >=0 & alpha <= 1,
                            msg = "alpha correct")
  }
  
  # Pre processing: S, b calculation --------------
  eq_mat <- create_S_b_matrix(n, prop_cde)
  S <- eq_mat[[1]]
  b <- eq_mat[[2]]
  
  if (lambda == -1){
    solution = solve(S) %*% b
    return(solution)
  }
    
  if (alpha*lambda >= delta){
    delta <- alpha*lambda
  }
  
  # loss function ------------------------
  ## c(x) = x^T D_mat x - dvec^T x
  D_mat.1 <- 1/2 * t(S) %*% S
  D_mat <- rbind(cbind(D_mat.1, matrix(0, nrow = nrow(D_mat.1),
                                       ncol = nrow(D_mat.1) - 1)),
                 cbind(matrix(0, nrow = nrow(D_mat.1) - 1, 
                                 ncol = nrow(D_mat.1)),
                       diag(rep(delta, nrow(D_mat.1) - 1))))
  
  dvec <- c(t(S) %*% b, rep(-lambda*(1-alpha), nrow(D_mat.1) - 1))
    
  # inequality constraints ------------------------
  
  ## z_i >= a_i - a_{i+1}
  Amat1.1 <- diag(1, nrow = nrow(D_mat.1), ncol = nrow(D_mat.1))
  Amat1.2 <- pracma::Diag(rep(-1, nrow(D_mat.1)-1),k = +1) 
  Amat1.3 <- Amat1.1 + Amat1.2
  Amat1.4 <- Amat1.3[-nrow(Amat1.3),]
  Amat1 <- cbind(Amat1.4, diag(rep(1, nrow(D_mat.1) - 1)))
  
  ## z_i >= -a_i + a_{i+1}
  Amat2 <- cbind(-Amat1.4, diag(rep(1, nrow(D_mat.1) - 1)))
  
  ## x >= 0
  Amat3 <- cbind(diag(rep(1, nrow(D_mat.1))), matrix(0, nrow = nrow(D_mat.1),
                                                    ncol = nrow(D_mat.1) - 1))
  
  if (monotonically_increasing) {
    ## a_{i+1} - a_i >= 0 & drop z_i >= -a_i + a_{i+1}
    Amat4 <- cbind(-Amat1.4, diag(rep(0, nrow(D_mat.1) - 1)))
    Amat <- rbind(Amat1, Amat3, Amat4)
  } else {
    Amat <- rbind(Amat1, Amat2, Amat3)
  }
  
  b_0_vec <- rep(0, nrow(Amat))

  # "equality" constraint ------------------------
  ## to get correct scaling 
  ## S[final_row]^T x = 1
  if (scaling_constraint){
  Amat5 <- cbind(rbind(S[nrow(S), ],
              -S[nrow(S), ]), matrix(0, nrow = 2, ncol = nrow(D_mat.1) - 1))
  b_0_5 <- c(1,-1)
  
  Amat <- rbind(Amat, Amat5)
  b_0_vec <- c(b_0_vec, b_0_5)
  }
  
  
  # solving qp ------------------------
  qp_solve <- quadprog::solve.QP(Dmat = D_mat, dvec = dvec, 
                     Amat = t(Amat), bvec = b_0_vec, factorize = F)

  solution <- qp_solve$solution[1:ncol(S)]
  
  return(solution)
}


vis_stepwise_scaling <- function(stepwise_scaling, first_df, second_df,
                                 title = "", scale= T){
  vis1 <- data.frame(multiplier = stepwise_scaling, 
                     x = 1:length(stepwise_scaling)) %>%
    ggplot() +
    geom_point(aes(x = x, y = multiplier)) +
    geom_line(aes(x = x, y = multiplier)) +
    labs(x = "threshold for cde",
         y = "scaling")
  
  second_df$multiplier <- c(1, stepwise_scaling)

  all_df2 <- first_df %>% left_join(second_df, by = c("g_id", "g_id2")) %>%
    mutate(density3 = density * multiplier)
  if (scale){
    delta_x <- 1/sum(all_df2$density)
    total <- sum(all_df2$density3)*delta_x
    all_df2 <- all_df2 %>% 
      mutate(density3 = density3 / total)
  }
  


  vis2 <- all_df2 %>% ggplot() +
    geom_line(aes(x = yy, y = density)) +
    geom_point(aes(x = yy, y = density3), color = "red", size = .5) +
    geom_line(aes(x = yy, y = density3), color = "red") +
    labs(x = "range of y values",
         y = "probability distribution (update correctly scaled)")
    
  
  grid.arrange(vis1, vis2, nrow = 1, top = title)
  
  return(invisible(list(vis1, vis2)))
}
  
```

# All comparsions 

## LP

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_lp <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = -1)
  
vis_stepwise_scaling(solution_lp, first_df, second_df, title = "lp", scale = F)
vis_stepwise_scaling(solution_lp, first_df, second_df, title = "lp", scale = T)

```
## QP, l1

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam1 <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1,
                                          alpha = 0)
  
vis_stepwise_scaling(solution_qp_l1_lam1, 
                     first_df, second_df, title = "qp, lambda = 1, l1")
```


```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam.1 <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-01,
                                          alpha = 0)
  
vis_stepwise_scaling(solution_qp_l1_lam.1, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l1")
```

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam.01 <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-02,
                                          alpha = 0)
  
vis_stepwise_scaling(solution_qp_l1_lam.01, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l1")
```

## QP, l2

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam1 <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1,
                                          alpha = 1)
  
vis_stepwise_scaling(solution_qp_l2_lam1, 
                     first_df, second_df, title = "qp, lambda = 1, l2")
```


```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam.1 <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-01,
                                          alpha = 1)
  
vis_stepwise_scaling(solution_qp_l2_lam.1, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l2")
```

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam.01 <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-02,
                                          alpha = 1)
  
vis_stepwise_scaling(solution_qp_l2_lam.01, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l2")
```

## QP, l1, monotonically increasing


```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam1mi <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1,
                                          alpha = 0,
                                          monotonically_increasing = T)
  
vis_stepwise_scaling(solution_qp_l1_lam1mi, 
                     first_df, second_df, 
                     title = "qp, lambda = 1, l1\n monotonically increasing")
```


```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam.1mi <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-01,
                                          alpha = 0,
                                          monotonically_increasing = T)
  
vis_stepwise_scaling(solution_qp_l1_lam.1mi, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l1\n monotonically increasing")
```

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam.01mi <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-02,
                                          alpha = 0,
                                          monotonically_increasing = T)
  
vis_stepwise_scaling(solution_qp_l1_lam.01mi, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l1\n monotonically increasing")
```
## QP, l2, monotonically increasing

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam1mi <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1,
                                          alpha = 1,
                                          monotonically_increasing = T)
  
vis_stepwise_scaling(solution_qp_l2_lam1mi, 
                     first_df, second_df, 
                     title = "qp, lambda = 1, l2\n monotonically increasing")
```


```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam.1mi <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-01,
                                          alpha = 1,
                                          monotonically_increasing = T)
  
vis_stepwise_scaling(solution_qp_l2_lam.1mi, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l2\n monotonically increasing")
```

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam.01mi <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-02,
                                          alpha = 1,
                                          monotonically_increasing = T)
  
vis_stepwise_scaling(solution_qp_l2_lam.01mi, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l2\n monotonically increasing")
```

## QP, l1 (scale not needed)

```{r error = T}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam1S <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1,
                                          alpha = 0, scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l1_lam1S, 
                     first_df, second_df, title = "qp, lambda = 1, l1, S")
```


```{r error = T}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam.1 <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-01,
                                          alpha = 0, scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l1_lam.1, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l1")
```

```{r error = T}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam.01 <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-02,
                                          alpha = 0, scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l1_lam.01, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l1")
```

## QP, l2 (scale not needed)

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam1S <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1,
                                          alpha = 1, scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l2_lam1S, 
                     first_df, second_df, title = "qp, lambda = 1, l2, S")
vis_stepwise_scaling(solution_qp_l2_lam1S, 
                     first_df, second_df, title = "qp, lambda = 1, l2, S.",
                     scale = F)
```


```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam.1S <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-01,
                                          alpha = 1, scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l2_lam.1S, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l2 S")
vis_stepwise_scaling(solution_qp_l2_lam.1S, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l2 S.", scale = F)
```

```{r error = T}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam.01S <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-02,
                                          alpha = 1,scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l2_lam.01, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l2 S")
```

## QP, l1, monotonically increasing (scale not needed)


```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam1miS <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1,
                                          alpha = 0,
                                          monotonically_increasing = T, scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l1_lam1miS, 
                     first_df, second_df, 
                     title = "qp, lambda = 1, l1\n monotonically increasing S")
```


```{r error = T}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam.1miS <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-01,
                                          alpha = 0,
                                          monotonically_increasing = T,scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l1_lam.1mi, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l1\n monotonically increasing S")
```

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l1_lam.01miS <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-02,
                                          alpha = 0,
                                          monotonically_increasing = T,
                                          scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l1_lam.01mi, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l1\n monotonically increasing S")
```

## QP, l2, monotonically increasing (scale not needed)

```{r}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam1miS <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1,
                                          alpha = 1,
                                          monotonically_increasing = T,scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l2_lam1mi, 
                     first_df, second_df, 
                     title = "qp, lambda = 1, l2\n monotonically increasing S")
```


```{r error = T}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam.1miS <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-01,
                                          alpha = 1,
                                          monotonically_increasing = T, scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l2_lam.1miS, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l2\n monotonically increasing S")
```

```{r error = T}
prob_cde <- second_df$prop_lag[-1]
n <- length(prop_cde) - 1
solution_qp_l2_lam.01miS <- stepwise_conformal_cde_update(n, prob_cde,
                                          lambda = 1e-02,
                                          alpha = 1,
                                          monotonically_increasing = T, scaling_constraint = T)
  
vis_stepwise_scaling(solution_qp_l2_lam.01mi, first_df, second_df, 
                     title = "qp, lambda = 1e-01, l2\n monotonically increasing S")
```


