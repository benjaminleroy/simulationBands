---
title: "lei-wasserman-marginal"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{lei-wasserman-marginal}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = F}
knitr::opts_chunk$set(fig.heigh = 7, fig.width = 7)
```


```{r, warning = F, message = F}
library(tidyverse)
library(gridExtra)

```


# Data Simulation

```{r functions-data-generation, echo = F}

inner_f <- function(x){
  return((x-1)^2*(x+1))
}

inner_g <- function(x){
  value <- 2*sqrt(ifelse(x >= -.5, 
                  x+.5, 0))
  return(value)
}
inner_mixture <- function(x, group){
  value <- ifelse(group == 1,
                  inner_f(x) - inner_g(x),
                  inner_f(x) + inner_g(x))
}
inner_sigma <- function(x){
  return(1/4 + abs(x))
}
lei_wasserman_data <- function(n = 1000, sigma_function = inner_sigma){
  x <- runif(n = n, min = -1.5, 1.5)
  group_id <- sample(c(1,2), replace = T, size = n)
  
  mu <- inner_mixture(x, group_id)
  sigma <- sigma_function(x)
  y <- rnorm(n = n,
             mean = mu, sd = sigma )
  
  return(data.frame(x = x, 
                    y = y))
  
}

inner_sigma_zero <- function(x){
  return(0.0001)
}


```

```{r , echo = F}
data <- lei_wasserman_data()
data_test <- lei_wasserman_data()


mean_lines <- lei_wasserman_data(10000, sigma_function = inner_sigma_zero)
```

```{r , echo = F}
data %>% 
  ggplot() +
  geom_point(aes(x = x , y = y)) +
  geom_point(data = mean_lines,
             aes(x =x , y =y), color = "red")
```



```{r , echo = F, eval = F}
library(devtools)
#install_github("rizbicki/predictionBands")
library(predictionBands)
library(FlexCoDE)
set.seed(1)
fit <- fit_predictionBands(matrix(data$x), 
                           matrix(data$y))
bands <- predict(fit, matrix(sort(data$x)),
                 type = "cd", alpha = .5)


bands[[4]] %>% length

marginal_plot_df <- function(bands){
  vis_data <- data.frame()
  
  num_obs <- length(bands$prediction_bands_which_belong)
  for (ii in 1:num_obs){
    inner_y <- bands$y_grid[bands$prediction_bands_which_belong[[ii]]]
    # some have none- which is odd 
    if (length(inner_y) > 0){
    vis_data <- rbind(vis_data,
             data.frame(id = ii,
               y = inner_y))
    }
    
  }
  return(vis_data)
  
}

vis_data <- marginal_plot_df(bands)

marginal_vis_data <- data.frame(x = sort(data$x),
           id = 1:nrow(data)) %>%
  left_join(vis_data, by = "id")

marginal_vis_data %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(shape = ".") + 
  geom_point(data = mean_lines,
             aes(x =x , y =y), color = "red")

```



# Goal 1

1. Show that a conformal score with proportion mass is smarter than $\lambda$,
2. explore smoothing?

## better conformal score

First, we will assume we can perfectly model in Lei and Wasserman's example. Then naturally we'd get better coverage.

### step 1: discrete cde

```{r , echo = F}

cde_lei_wassserman_funct <- function(x) {
  mu <- inner_mixture(rep(x,2), c(1,2))
  sigma <- inner_sigma(x)
  
  marginal_cde <- function(y) {
    1/2 * dnorm(y, mean = mu[1], sd = sigma) +
      1/2 * dnorm(y, mean = mu[2], sd = sigma)
  } 
  return(marginal_cde)
}


cde_on_grid <- function(x, range = c(-8,8), n = 100){
  y_range <- seq(range[1], range[2], 
                 length.out = n)
    
  df_out <- data.frame()
  for (idx in 1:length(x)) {
    inner_cde_values <- cde_lei_wassserman_funct(x[idx])(y_range)
    df_out <- rbind(df_out,
                    data.frame(x = x[idx],
                               y = y_range,
                               cde = inner_cde_values))
  }
  return(df_out)
}

discrete_cde_df <- cde_on_grid(sort(data$x))
#discrete_cde_df %>% head

```
```{r , echo = F}
#cde_vec <- discrete_cde_df %>% filter(x == discrete_cde_df$x[1]) %>% pull(cde)

inner_discrete_mass_cde <- function(cde_vec, delta_y = 16/99){
  ordering <- order(cde_vec,decreasing = F)
  mass_estimate <- cumsum(sort(cde_vec)) * delta_y
  mass_from_cde <- rep(NA, length(cde_vec))
  mass_from_cde[ordering] <- mass_estimate
  return(mass_from_cde)
}

# tests
if (FALSE) {
  cde_vec <- c(.11,.19,.09,.1,.3,.21)
  delta_y <- 1
  mass_expected <- c(.3,.49,.09,.19, 1,.7)
  mass <- inner_discrete_mass_cde(cde_vec, delta_y)
  testthat::expect_equal(mass, mass_expected)
  
  reorder <- sample(6)
  cde_vec2 <- cde_vec[reorder]
  mass_expected2 <-  mass_expected[reorder]
  mass2 <- inner_discrete_mass_cde(cde_vec2, delta_y)
  testthat::expect_equal(mass2, mass_expected2)

}
```

```{r, echo = F}

# making sure that we only have 1 observation with x value
discrete_cde_df %>% 
  group_by(x) %>%
  summarize(t = n()) %>% pull(t) %>% 
  unique() %>%
  length() %>% 
  testthat::expect_equal(., 1)

discrete_info_all <- discrete_cde_df %>% 
  group_by(x) %>% 
  nest() %>%
  mutate(data = purrr::map(data, function(df) {
    mass_inner <- inner_discrete_mass_cde(cde_vec = df$cde)
    df$mass_estimate <- mass_inner
    return(df)})) %>%
  unnest(data) 

#discrete_info_all %>% head
```

# Conformal values (cde threshold)

```{r , echo = F}
data_calibrate <- lei_wasserman_data(n = 200)

conformal_with_cde <- data_calibrate %>% 
  mutate(cde = cde_lei_wassserman_funct(x)(y),
         mass = purrr::pmap(list(cde, x), 
                            function(cde,x){
                              delta_y = 16/99
                              cde_grid <- cde_on_grid(x = x)$cde
                              mass_estimate <- sum(cde_grid[cde_grid >= cde]) * delta_y
                              return(mass_estimate)
                            })) %>%
  unnest(mass)


```


```{r, echo = F}
alpha <- .8
cde_cut <- quantile(conformal_with_cde$cde, alpha)
mass_cut <- quantile(conformal_with_cde$mass, alpha)

a <- discrete_info_all %>% 
  filter(cde >= cde_cut) %>%
  ggplot() +
  geom_point(aes(x = x, y = y)) +
  ylim(-8,8) +
  geom_point(data = data_test, aes(x = x , y = y), color = "red", shape = ".")
  
  

b <- discrete_info_all %>% 
  filter(mass_estimate >= mass_cut) %>%
  ggplot() +
  geom_point(aes(x = x, y = y)) +
  ylim(-8,8) +
  geom_point(data = data_test, aes(x = x , y = y), color = "red", shape = ".")

grid.arrange(a, b, nrow = 1, 
             top = sprintf("alpha = %.2f (confidence level = %.2f)", 
                           alpha, 1 - alpha))
```


```{r , echo = F}
alpha <- .5
cde_cut <- quantile(conformal_with_cde$cde, alpha)
mass_cut <- quantile(conformal_with_cde$mass, alpha)

a <- discrete_info_all %>% 
  filter(cde >= cde_cut) %>%
  ggplot() +
  geom_point(aes(x = x, y = y)) +
  ylim(-8,8) +
  geom_point(data = data_test, aes(x = x , y = y), color = "red", shape = ".")
  
  

b <- discrete_info_all %>% 
  filter(mass_estimate >= mass_cut) %>%
  ggplot() +
  geom_point(aes(x = x, y = y)) +
  ylim(-8,8) +
  geom_point(data = data_test, aes(x = x , y = y), color = "red", shape = ".")

grid.arrange(a, b, nrow = 1, 
             top = sprintf("alpha = %.2f (confidence level = %.2f)", 
                           alpha, 1 - alpha))
```

```{r, echo = F}

alpha = .2
cde_cut <- quantile(conformal_with_cde$cde, alpha)
mass_cut <- quantile(conformal_with_cde$mass, alpha)

a <- discrete_info_all %>% 
  filter(cde >= cde_cut) %>%
  ggplot() +
  geom_point(aes(x = x, y = y)) +
  ylim(-8,8) +
  geom_point(data = data_test, aes(x = x , y = y), 
             color = "red", shape = ".")
  
  

b <- discrete_info_all %>% 
  filter(mass_estimate >= mass_cut) %>%
  ggplot() +
  geom_point(aes(x = x, y = y)) +
  ylim(-8,8) +
  geom_point(data = data_test, aes(x = x , y = y), 
             color = "red", shape = ".")

grid.arrange(a, b, nrow = 1, 
             top = sprintf("alpha = %.2f (confidence level = %.2f)", 
                           alpha, 1 - alpha))
```

# CDE vs Mass visuals

```{r, echo = F}
a2 <- discrete_info_all  %>%
  ggplot() +
  geom_point(aes(x = x, y = y, color = cde)) +
  theme(legend.position = "bottom")

b2 <- discrete_info_all  %>%
  ggplot() +
  geom_point(aes(x = x, y = y, color = mass_estimate)) +
  theme(legend.position = "bottom")

grid.arrange(a2, b2, nrow = 1)
```


